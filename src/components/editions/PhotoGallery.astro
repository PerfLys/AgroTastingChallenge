---
import fs from "node:fs/promises";
import path from "node:path";
import crypto from "node:crypto";
import sharp from "sharp";

interface Props {
  photos: string[];
  altPrefix?: string;
  previewTitle?: string;
  closeLabel?: string;
  viewPhotoLabelPrefix?: string;
  prevLabel?: string;
  nextLabel?: string;
  downloadLabel?: string;
}

const {
  photos,
  altPrefix = "Photo",
  previewTitle = "Aperçu",
  closeLabel = "Fermer",
  viewPhotoLabelPrefix = "Voir la photo",
  prevLabel = "Précédent",
  nextLabel = "Suivant",
  downloadLabel = "Télécharger",
} = Astro.props;
const galleryId = `gallery-${Math.random().toString(36).slice(2)}`;

function isLocalPublicPath(src: string): boolean {
  // Handle site-local absolute paths like `/uploads/...` living in `public/`.
  return src.startsWith("/") && !src.startsWith("//") && !src.includes("://");
}

async function getLocalFsPath(src: string): Promise<string | null> {
  if (!isLocalPublicPath(src)) return null;
  const fsPath = path.join(process.cwd(), "public", src);
  try {
    await fs.access(fsPath);
    return fsPath;
  } catch {
    // ignore
  }
  return null;
}

const GENERATED_DIR_PUBLIC = "/_generated/photos";
const GENERATED_DIR_FS = path.join(process.cwd(), "public", "_generated", "photos");
const PHOTO_GALLERY_HASH_VERSION = "v2"; // bump to invalidate old variants when generation settings change

type GeneratedPhoto = {
  originalSrc: string;
  thumbSrc: string; // used in gallery AND as lightbox placeholder (ratio-preserving)
  lightboxSrc: string;
  isLocal: boolean;
};

async function ensureGeneratedDir() {
  await fs.mkdir(GENERATED_DIR_FS, { recursive: true });
}

function hashFromStat(stat: { size: number; mtimeMs: number }, src: string): string {
  return crypto
    .createHash("sha1")
    .update(`${PHOTO_GALLERY_HASH_VERSION}|${src}|${stat.size}|${stat.mtimeMs}`)
    .digest("hex")
    .slice(0, 16);
}

async function fileExists(fsPath: string): Promise<boolean> {
  try {
    await fs.access(fsPath);
    return true;
  } catch {
    return false;
  }
}

async function generateWebpIfMissing(opts: {
  inputFsPath: string;
  outputFsPath: string;
  resize:
    | { mode: "cover"; width: number; height: number }
    | { mode: "contain"; width: number };
  quality: number;
}): Promise<void> {
  if (await fileExists(opts.outputFsPath)) return;
  // See scripts/generate-images.mjs: during `astro build` we do not generate here.
  if (!import.meta.env?.DEV) return;
  const img = sharp(opts.inputFsPath, { failOn: "none" });
  if (opts.resize.mode === "cover") {
    img.resize(opts.resize.width, opts.resize.height, {
      fit: "cover",
      position: "attention",
      withoutEnlargement: true,
    });
  } else {
    img.resize({
      width: opts.resize.width,
      fit: "inside",
      withoutEnlargement: true,
    });
  }

  await img.webp({ quality: opts.quality }).toFile(opts.outputFsPath);
}

async function generateOne(src: string): Promise<GeneratedPhoto> {
  const inputFsPath = await getLocalFsPath(src);
  if (!inputFsPath) {
    // Remote or missing file: keep original src, no build-time processing.
    return {
      originalSrc: src,
      thumbSrc: src,
      lightboxSrc: src,
      isLocal: false,
    };
  }

  const stat = await fs.stat(inputFsPath);
  const hash = hashFromStat({ size: stat.size, mtimeMs: stat.mtimeMs }, src);

  const smallName = `${hash}-sm.webp`;
  const lightboxName = `${hash}-lb.webp`;

  const smallFs = path.join(GENERATED_DIR_FS, smallName);
  const lightboxFs = path.join(GENERATED_DIR_FS, lightboxName);

  // Two variants only:
  // - "sm": ratio-preserving (contain/inside) used in grid AND as lightbox placeholder
  // - "lb": large ratio-preserving for lightbox
  await Promise.all([
    generateWebpIfMissing({
      inputFsPath,
      outputFsPath: smallFs,
      resize: { mode: "contain", width: 480 },
      quality: 65,
    }),
    generateWebpIfMissing({
      inputFsPath,
      outputFsPath: lightboxFs,
      resize: { mode: "contain", width: 1600 },
      quality: 82,
    }),
  ]);

  return {
    originalSrc: src,
    thumbSrc: `${GENERATED_DIR_PUBLIC}/${smallName}`,
    lightboxSrc: `${GENERATED_DIR_PUBLIC}/${lightboxName}`,
    isLocal: true,
  };
}

await ensureGeneratedDir();
const generated = await Promise.all(photos.map(generateOne));

const lightboxPayload = generated.map((g) => ({
  // Placeholder while large WebP loads (must preserve original aspect ratio).
  thumbSrc: g.thumbSrc,
  src: g.lightboxSrc,
  downloadSrc: g.originalSrc,
}));
---

{photos.length === 0 ? null : (
  <>
    <div class="mt-5 grid grid-cols-2 sm:grid-cols-3 gap-3" data-gallery-root={galleryId}>
      {photos.map((src, idx) => {
        // Load first 6 images eagerly, rest lazily with low priority
        const isAboveFold = idx < 6;
        const g = generated[idx];
        return (
          <button
            type="button"
            class="group overflow-hidden rounded-2xl border border-neutral-200 dark:border-neutral-700 bg-white/60 dark:bg-neutral-950/20 text-left cursor-pointer relative"
            data-photo={src}
            data-index={idx}
            aria-label={`${viewPhotoLabelPrefix} ${idx + 1}`}
          >
            <img
              src={g?.thumbSrc ?? src}
              alt={`${altPrefix} ${idx + 1}`}
              class="w-full h-full object-cover aspect-[4/3] group-hover:scale-[1.03] transition-transform duration-300"
              loading={isAboveFold ? "eager" : "lazy"}
              decoding="async"
              fetchpriority={isAboveFold ? "high" : "low"}
              width="240"
              height="180"
              sizes="(max-width: 640px) 50vw, 33vw"
            />
            {/* Subtle loading placeholder */}
            <div class="absolute inset-0 bg-gradient-to-br from-neutral-100/50 to-neutral-200/30 dark:from-neutral-800/30 dark:to-neutral-900/20 opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none" />
          </button>
        );
      })}
    </div>

    <dialog class="atc-lightbox" data-gallery-dialog={galleryId}>
      <div class="atc-lightbox-container">
        <div class="atc-lightbox-header">
          <span class="atc-lightbox-counter" data-counter></span>
          <a class="atc-lightbox-download" data-download-link href="#" download aria-label={downloadLabel}>
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
              <polyline points="7 10 12 15 17 10"></polyline>
              <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
            <span class="sr-only">{downloadLabel}</span>
          </a>
          <button type="button" class="atc-lightbox-close" aria-label={closeLabel}>
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
        </div>
        <div class="atc-lightbox-content">
          <button type="button" class="atc-lightbox-nav atc-lightbox-prev" aria-label={prevLabel} data-nav="prev">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="15 18 9 12 15 6"></polyline>
            </svg>
          </button>
          <div class="atc-lightbox-image-wrapper">
            <img
              alt={previewTitle}
              class="atc-lightbox-image"
              data-lightbox-img
              decoding="async"
              loading="eager"
              sizes="100vw"
            />
            <div class="atc-lightbox-loading" data-loading-indicator aria-hidden="true">
              <span class="atc-lightbox-spinner" aria-hidden="true"></span>
              <span class="sr-only">Chargement…</span>
            </div>
          </div>
          <button type="button" class="atc-lightbox-nav atc-lightbox-next" aria-label={nextLabel} data-nav="next">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="9 18 15 12 9 6"></polyline>
            </svg>
          </button>
        </div>
      </div>
    </dialog>

    <script is:inline define:vars={{ galleryId, photos: lightboxPayload, altPrefix }}>
      (() => {
        const root = document.querySelector(`[data-gallery-root="${galleryId}"]`);
        const dialog = document.querySelector(`[data-gallery-dialog="${galleryId}"]`);
        const dialogImg = dialog?.querySelector("[data-lightbox-img]");
        const loadingEl = dialog?.querySelector("[data-loading-indicator]");
        const counter = dialog?.querySelector("[data-counter]");
        const prevBtn = dialog?.querySelector("[data-nav='prev']");
        const nextBtn = dialog?.querySelector("[data-nav='next']");
        const closeBtn = dialog?.querySelector(".atc-lightbox-close");
        const downloadLink = dialog?.querySelector("[data-download-link]");
        
        if (!root || !dialog || !dialogImg) return;

        let currentIndex = 0;
        const totalPhotos = photos.length;
        let loadToken = 0;

        function preload(url) {
          if (!url) return;
          const img = new Image();
          img.decoding = "async";
          img.src = url;
        }

        function setLoading(isLoading) {
          if (!loadingEl) return;
          loadingEl.classList.toggle("is-visible", Boolean(isLoading));
        }

        function updateImage(index) {
          if (index < 0 || index >= totalPhotos) return;
          currentIndex = index;
          const item = photos[index] || {};
          const token = ++loadToken;

          // Always start with the placeholder (already cached from the grid).
          // Keep it fully visible; we show a spinner instead of dimming.
          setLoading(Boolean(item.src) && item.src !== item.thumbSrc);

          // Instant placeholder (thumbnail)
          if (item.thumbSrc) {
            dialogImg.setAttribute("src", item.thumbSrc);
          }
          dialogImg.setAttribute("alt", `${altPrefix} ${index + 1}`);

          // Preload large image, then swap in.
          // IMPORTANT: ignore stale loads if user navigated away while it was loading.
          if (item.src && item.src !== item.thumbSrc) {
            const img = new Image();
            img.decoding = "async";
            img.onload = async () => {
              if (token !== loadToken || currentIndex !== index) return;
              try {
                // Hint the browser to decode before we swap to reduce flicker.
                if (typeof img.decode === "function") await img.decode();
              } catch {
                // ignore decode failures
              }
              if (token !== loadToken || currentIndex !== index) return;
              dialogImg.setAttribute("src", item.src);
              setLoading(false);
            };
            img.onerror = () => {
              if (token !== loadToken || currentIndex !== index) return;
              setLoading(false);
              console.warn("Failed to load image:", item.src);
            };
            img.src = item.src;
          } else {
            setLoading(false);
          }

          // Prefetch neighbors for smoother navigation
          const next = photos[index + 1];
          const prev = photos[index - 1];
          preload(next?.src);
          preload(prev?.src);
          preload(next?.thumbSrc);
          preload(prev?.thumbSrc);
          
          if (counter) {
            counter.textContent = `${index + 1} / ${totalPhotos}`;
          }

          if (downloadLink) {
            const href = item.downloadSrc || item.src || item.thumbSrc || "#";
            downloadLink.setAttribute("href", href);
          }
          
          // Update button states
          if (prevBtn) {
            prevBtn.classList.toggle("atc-lightbox-nav-disabled", index === 0);
            prevBtn.setAttribute("aria-disabled", String(index === 0));
          }
          if (nextBtn) {
            nextBtn.classList.toggle("atc-lightbox-nav-disabled", index === totalPhotos - 1);
            nextBtn.setAttribute("aria-disabled", String(index === totalPhotos - 1));
          }
        }

        function showImage(index) {
          updateImage(index);
          dialog.showModal();
          const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
          document.body.style.paddingRight = `${scrollbarWidth}px`;
          document.body.style.overflow = "hidden";
          document.documentElement.style.overflow = "hidden";
        }

        function closeLightbox() {
          // Invalidate any in-flight image load so it can't "win" after close/reopen.
          loadToken += 1;
          setLoading(false);
          dialog.close();
          document.body.style.overflow = "";
          document.documentElement.style.overflow = "";
          document.body.style.paddingRight = "";
        }

        // Open lightbox on thumbnail click
        root.addEventListener("click", (e) => {
          const btn = e.target instanceof Element ? e.target.closest("button[data-photo]") : null;
          if (!btn) return;
          const index = parseInt(btn.getAttribute("data-index") || "0", 10);
          showImage(index);
        });

        // Navigation
        if (prevBtn) {
          prevBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            if (currentIndex > 0) {
              updateImage(currentIndex - 1);
            }
          });
        }

        if (nextBtn) {
          nextBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            if (currentIndex < totalPhotos - 1) {
              updateImage(currentIndex + 1);
            }
          });
        }

        // Close button
        if (closeBtn) {
          closeBtn.addEventListener("click", closeLightbox);
        }

        // Close on backdrop click
        dialog.addEventListener("click", (e) => {
          if (e.target === dialog) closeLightbox();
        });

        // Keyboard navigation
        dialog.addEventListener("keydown", (e) => {
          if (e.key === "Escape") {
            closeLightbox();
          } else if (e.key === "ArrowLeft" && currentIndex > 0) {
            updateImage(currentIndex - 1);
          } else if (e.key === "ArrowRight" && currentIndex < totalPhotos - 1) {
            updateImage(currentIndex + 1);
          }
        });

        // Close on dialog close event
        dialog.addEventListener("close", () => {
          loadToken += 1;
          setLoading(false);
          document.body.style.overflow = "";
          document.documentElement.style.overflow = "";
          document.body.style.paddingRight = "";
        });
      })();
    </script>
  </>
)}

<style>
  dialog.atc-lightbox {
    margin: 0;
    padding: 0;
    max-width: 100vw;
    max-height: 100vh;
    width: 100vw;
    height: 100vh;
    border: none;
    background: transparent;
    z-index: 9999;
    overflow: hidden;
  }

  dialog.atc-lightbox::backdrop {
    background: rgba(0, 0, 0, 0.9);
    backdrop-filter: blur(4px);
  }

  .atc-lightbox-container {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    background: rgba(0, 0, 0, 0.95);
  }

  .atc-lightbox-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1rem 1.5rem;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    gap: 0.75rem;
  }

  .atc-lightbox-counter {
    color: rgba(255, 255, 255, 0.9);
    font-size: 0.875rem;
    font-weight: 500;
  }

  .atc-lightbox-download {
    margin-left: auto;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: rgba(255, 255, 255, 0.9);
    padding: 0.5rem 0.65rem;
    border-radius: 0.5rem;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    text-decoration: none;
  }

  .atc-lightbox-download:hover {
    background: rgba(255, 255, 255, 0.2);
    border-color: rgba(255, 255, 255, 0.3);
  }

  .atc-lightbox-close {
    background: transparent;
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: rgba(255, 255, 255, 0.9);
    padding: 0.5rem;
    border-radius: 0.5rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
  }

  .atc-lightbox-close:hover {
    background: rgba(255, 255, 255, 0.1);
    border-color: rgba(255, 255, 255, 0.3);
  }

  .atc-lightbox-content {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    padding: 2rem;
    gap: 1rem;
  }

  .atc-lightbox-image-wrapper {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    height: 100%;
    width: 100%;
    min-width: 0;
    min-height: 0;
    overflow: hidden;
  }

  .atc-lightbox-loading {
    position: absolute;
    right: 12px;
    bottom: 12px;
    width: 36px;
    height: 36px;
    border-radius: 999px;
    background: rgba(0, 0, 0, 0.35);
    border: 1px solid rgba(255, 255, 255, 0.18);
    display: grid;
    place-items: center;
    opacity: 0;
    transform: translateY(4px);
    transition: opacity 0.15s ease, transform 0.15s ease;
    pointer-events: none;
  }

  .atc-lightbox-loading.is-visible {
    opacity: 1;
    transform: translateY(0);
  }

  .atc-lightbox-spinner {
    width: 16px;
    height: 16px;
    border-radius: 999px;
    border: 2px solid rgba(255, 255, 255, 0.35);
    border-top-color: rgba(255, 255, 255, 0.9);
    animation: atc-spin 0.9s linear infinite;
  }

  @keyframes atc-spin {
    to {
      transform: rotate(360deg);
    }
  }

  .atc-lightbox-image {
    position: absolute;
    inset: 0;
    margin: auto;
    max-width: none;
    max-height: none;
    width: 100%;
    height: 100%;
    object-fit: contain !important;
    border-radius: 0.5rem;
    display: block;
  }

  .atc-lightbox-nav {
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: rgba(255, 255, 255, 0.9);
    padding: 1rem;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    width: 48px;
    height: 48px;
    flex-shrink: 0;
  }

  .atc-lightbox-nav:hover:not(.atc-lightbox-nav-disabled) {
    background: rgba(255, 255, 255, 0.2);
    border-color: rgba(255, 255, 255, 0.3);
    transform: scale(1.05);
  }

  .atc-lightbox-nav:active:not(.atc-lightbox-nav-disabled) {
    transform: scale(0.95);
  }

  .atc-lightbox-nav-disabled {
    opacity: 0.3;
    cursor: not-allowed;
  }

  @media (min-width: 1920px) {
    .atc-lightbox-image-wrapper {
      max-width: calc(100vw - 300px);
      max-height: calc(100vh - 140px);
    }
  }

  @media (max-width: 640px) {
    .atc-lightbox-content {
      padding: 1rem;
      gap: 0.5rem;
    }

    .atc-lightbox-image-wrapper {
      max-width: calc(100vw - 120px);
    }

    .atc-lightbox-nav {
      width: 40px;
      height: 40px;
      padding: 0.75rem;
    }
  }
</style>


